---
layout: post
title: "java学习(一)"
description: ""
category: java
tags: [java]
---
####前言
这段时间在看《Thinging in java》这本书，虽然以前也写过一些java的代码，但是总感觉对这门流行的强类型
语言了解的不够深入，所以决定从头来学习一下java，编写java程序显然没有写c++那样有那么多的疑惑和顾虑，但是
想要编写出好的java程序，还是应该对它有更深入的了解，我会从java语言一直到java虚拟机进行学习更新，废话少
说，直接从头开始。

#####java存储对象

  1. 寄存器：最快的存储区，但java不允许用户操作
  2. 堆栈：位于RAM中，这是c，c++主要的内存分配区，但是java对象并不存在此地，而是存储一些对象的句柄和
一些自动变量（他们占用的空间小，用堆栈提高效率）
  3. 堆：通用内存池（RAM中），存放所有java对象
  4. 常量存储：通常直接存储于程序代码内部，他们永远不会被改变
  5. 非RAM存储：最基本的例子就是流对象和持久化对象，如jdbc就能够实现持久化对象（磁盘）和RAM对象的转换

java有高可移植性的原因是java的基本类型（boolean，char，byte，short，int，long，float，double）
所占的存储空间的大小不会随机器硬件架构的变化而变化

#####static关键字
经常我们写第一个java程序都会遇到一个困惑，就是在main方法中为什么只能调用本类底下的static方法？
  
  * 原因很简单，就是方法是基于对象调用的。而我们写一个小程序，包含main的类并没有实例化成对象，所以一般
方法是不能被main调用的。但是静态方法不同，它不依赖于类被实例化成对象，可以直接通过ObjectName.StaticM
ethod调用。

通常类的static方法可以直接调用，其static变量也始终只有一分存储空间，不管你实例化多少对象。

#####java基本语法要点

  1. new是一个最常用的操作符
  2. 基于对象（如Integer）使用==与equals时要注意，到底是比较实际内容还是对象的应用
  3. 在打印（print）时，使用+，+=等字符串重载操作符时应留意类型转换
  4. java允许基本数据类型之间的强制转换，但是永远不要转换boolean，类转换必须得有前提
  5. switch的选择值必须是整型值如int，char等
  6. java中新引入的语法就如foreach，可以这样使用：
  ` for(object p : objectArray)`

#####类的初始化

java沿用了c++通过构造器来初始化类的做法，但是java没有析构函数，它的垃圾类的回收得依靠jvm的垃圾回收器
来进行，如果类中没有构造器，java会自动生成默认的类构造器，对于程序员已经定义的构造器，那么必须按照
构造器来初始化类，否则就会报错。当然java也支持重载，可以通过参数列表和返回值来区分重载方法，如果找不到
合适的重载函数，java会根据数据类型来进行适当地提升和窄化，但遵循类型转化的原则。

在类中我们会经常使用this关键字，它代表着当前对象，反过来我们就可以想想上面的static关键字，static方法
就是没有this关键字的方法，也就是说在static方法里面是不能调用非static方法的，上面的main困惑也可以得到
解释。所以static相当于一个全局函数，并不是真正地面向对象。

对于类的成员初始化原则有：

  1. 方法的局部变量必须手动初始化
  2. 对于类的数据成员字段，基本数据类型会被初始化为0，而对象引用会被初始化为null

对于类的成员初始化顺序有原则：

  1. 自动初始化的变量要先于构造器的初始化
  2. static成员要先于非static成员的初始化，而且对于这个类，只会被初始化一次

其实我们可以这样简单地理解：构造器也是static方法。初始化过程如下：

  1. 首次执行时，java解释器查找类路径，定位object.class,然后载入，执行static初始化。
  2. 当用new创建对象时，现在堆上分配足够的空间，且这块空间会被清零
  3. 执行自动初始化动作和执行构造器。

这里有一个困惑：何为首次？

java1.5中引入了一个很强大的关键字：enum，它是一个整型常量集，声明方法：

    public enum Spiciness{
      NOT, MILD,MEDIUM
    }
它还提供了toString(),ordinal(),values()等方法，并可以在switch中使用，是构造常量集合的不二选择。

#####复用类
java中类的复用是通过extends关键字来实现的，当我们需要编写各种功能有差异的类时，就需要继承，
  
  * 首先从继承类的构造器开始说起吧，当基类中需要显式地构造自己的时候，我们需要在派生类的构造器中显式地
构造基类，使用super(参数)来实现，即使你没有去构造基类，也是java帮你做了这部分工作
  * 组合和继承都允许在新的类中放置子对象，组合是显示地这样做，但是继承是隐式的，在选择组合和继承的
时候得慎重，有一个准则可以好好理解一下：用继承表示行为间的差异，用字段（组合）显示状态的变化
  * finally与final的区别在于，finally是try后面必须得执行的代码段，而final表示常量，即不能被改变，与之
相近的一个定义就是static表示只有一份，在其定义处或构造器中必须对其进行初始化。
  * protected关键字是为继承所设计的，即基类中的protected方法可以在派生类中被调用。
  * 在继承中最重要的概念就是向上转型，向上转型是是较专用类型向较通用类型转化，这种转化总是很安全，因为
基类总是比派生类窄

多态就是借助于向上转型来实现正确的方法调用的，只有能被覆盖的一般方法才能实现多态，在实现多态的过程中，
正确的方法调用是通过动态绑定来实现的。在多态中构造顺序为：

  1. 调用基类的构造器，它是从继承的根开始调用的，直到构造最底层的派生类
  2. 按声明顺序调用成员的初始化方法
  3. 调用派生类的构造器主体

当然在构造之前必须得分配足够的空间，这是前提。

继承提供了一个构造抽象类的机制，而接口则提供了java抽象方法的机制，在接口中的方法必须是定义成public的
，成员数据域一般是隐式的static和final的。我们只能继承一个类，但是我们能继承多个接口。总的来说，接口
就是有一堆（抽象）方法的类，需要你去覆写之。

我们使用接口的理由如下：

  * 为了能够向上转型成为多个基类型
  * 防止客户端程序员创建该类的对象，确保只是建立一个接口

我们使用接口最好的例子就是接口与工厂类的结合，能够写出让我们赏心悦目的代码。

####后记
多态和接口是java中的重要概念，需要在实践中去好好把握他们的使用，总之：理解向上转型是使用好多态和接口
的必要条件，学会用基类去调用各种派生类的不同方法。
































































  






























   
   
  
  
	
	
	
	
	
	
	
	
	
	
	
	
  